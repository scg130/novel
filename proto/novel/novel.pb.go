// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/novel/novel.proto

package go_micro_service_novel

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type VipType int32

const (
	VipType_NO_VIP VipType = 0
	VipType_IS_VIP VipType = 1
)

var VipType_name = map[int32]string{
	0: "NO_VIP",
	1: "IS_VIP",
}

var VipType_value = map[string]int32{
	"NO_VIP": 0,
	"IS_VIP": 1,
}

func (x VipType) String() string {
	return proto.EnumName(VipType_name, int32(x))
}

func (VipType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{0}
}

type DelNoteReq struct {
	Uid                  int32    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	NovelId              int32    `protobuf:"varint,2,opt,name=novel_id,json=novelId,proto3" json:"novel_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DelNoteReq) Reset()         { *m = DelNoteReq{} }
func (m *DelNoteReq) String() string { return proto.CompactTextString(m) }
func (*DelNoteReq) ProtoMessage()    {}
func (*DelNoteReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{0}
}
func (m *DelNoteReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelNoteReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelNoteReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelNoteReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelNoteReq.Merge(m, src)
}
func (m *DelNoteReq) XXX_Size() int {
	return m.Size()
}
func (m *DelNoteReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DelNoteReq.DiscardUnknown(m)
}

var xxx_messageInfo_DelNoteReq proto.InternalMessageInfo

func (m *DelNoteReq) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DelNoteReq) GetNovelId() int32 {
	if m != nil {
		return m.NovelId
	}
	return 0
}

type SetVipChapterReq struct {
	NovelId              int32    `protobuf:"varint,1,opt,name=novel_id,json=novelId,proto3" json:"novel_id,omitempty"`
	MinChapter           int32    `protobuf:"varint,2,opt,name=min_chapter,json=minChapter,proto3" json:"min_chapter,omitempty"`
	MaxChapter           int32    `protobuf:"varint,3,opt,name=max_chapter,json=maxChapter,proto3" json:"max_chapter,omitempty"`
	IsVip                int32    `protobuf:"varint,4,opt,name=is_vip,json=isVip,proto3" json:"is_vip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetVipChapterReq) Reset()         { *m = SetVipChapterReq{} }
func (m *SetVipChapterReq) String() string { return proto.CompactTextString(m) }
func (*SetVipChapterReq) ProtoMessage()    {}
func (*SetVipChapterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{1}
}
func (m *SetVipChapterReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVipChapterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVipChapterReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVipChapterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVipChapterReq.Merge(m, src)
}
func (m *SetVipChapterReq) XXX_Size() int {
	return m.Size()
}
func (m *SetVipChapterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVipChapterReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetVipChapterReq proto.InternalMessageInfo

func (m *SetVipChapterReq) GetNovelId() int32 {
	if m != nil {
		return m.NovelId
	}
	return 0
}

func (m *SetVipChapterReq) GetMinChapter() int32 {
	if m != nil {
		return m.MinChapter
	}
	return 0
}

func (m *SetVipChapterReq) GetMaxChapter() int32 {
	if m != nil {
		return m.MaxChapter
	}
	return 0
}

func (m *SetVipChapterReq) GetIsVip() int32 {
	if m != nil {
		return m.IsVip
	}
	return 0
}

type NovelListResp struct {
	Novels               []*NovelData `protobuf:"bytes,1,rep,name=novels,proto3" json:"novels,omitempty"`
	Code                 int32        `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Pagnation            *Pagnation   `protobuf:"bytes,3,opt,name=pagnation,proto3" json:"pagnation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NovelListResp) Reset()         { *m = NovelListResp{} }
func (m *NovelListResp) String() string { return proto.CompactTextString(m) }
func (*NovelListResp) ProtoMessage()    {}
func (*NovelListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{2}
}
func (m *NovelListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NovelListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NovelListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NovelListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NovelListResp.Merge(m, src)
}
func (m *NovelListResp) XXX_Size() int {
	return m.Size()
}
func (m *NovelListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_NovelListResp.DiscardUnknown(m)
}

var xxx_messageInfo_NovelListResp proto.InternalMessageInfo

func (m *NovelListResp) GetNovels() []*NovelData {
	if m != nil {
		return m.Novels
	}
	return nil
}

func (m *NovelListResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *NovelListResp) GetPagnation() *Pagnation {
	if m != nil {
		return m.Pagnation
	}
	return nil
}

type NovelData struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Author               string   `protobuf:"bytes,3,opt,name=author,proto3" json:"author,omitempty"`
	CateId               int64    `protobuf:"varint,4,opt,name=cate_id,json=cateId,proto3" json:"cate_id,omitempty"`
	CateName             string   `protobuf:"bytes,5,opt,name=cate_name,json=cateName,proto3" json:"cate_name,omitempty"`
	Img                  string   `protobuf:"bytes,6,opt,name=img,proto3" json:"img,omitempty"`
	ChapterTotal         int64    `protobuf:"varint,7,opt,name=chapter_total,json=chapterTotal,proto3" json:"chapter_total,omitempty"`
	ChapterCurrent       int64    `protobuf:"varint,8,opt,name=chapter_current,json=chapterCurrent,proto3" json:"chapter_current,omitempty"`
	CreateAt             string   `protobuf:"bytes,9,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	Sort                 int32    `protobuf:"varint,10,opt,name=sort,proto3" json:"sort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NovelData) Reset()         { *m = NovelData{} }
func (m *NovelData) String() string { return proto.CompactTextString(m) }
func (*NovelData) ProtoMessage()    {}
func (*NovelData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{3}
}
func (m *NovelData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NovelData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NovelData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NovelData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NovelData.Merge(m, src)
}
func (m *NovelData) XXX_Size() int {
	return m.Size()
}
func (m *NovelData) XXX_DiscardUnknown() {
	xxx_messageInfo_NovelData.DiscardUnknown(m)
}

var xxx_messageInfo_NovelData proto.InternalMessageInfo

func (m *NovelData) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NovelData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NovelData) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *NovelData) GetCateId() int64 {
	if m != nil {
		return m.CateId
	}
	return 0
}

func (m *NovelData) GetCateName() string {
	if m != nil {
		return m.CateName
	}
	return ""
}

func (m *NovelData) GetImg() string {
	if m != nil {
		return m.Img
	}
	return ""
}

func (m *NovelData) GetChapterTotal() int64 {
	if m != nil {
		return m.ChapterTotal
	}
	return 0
}

func (m *NovelData) GetChapterCurrent() int64 {
	if m != nil {
		return m.ChapterCurrent
	}
	return 0
}

func (m *NovelData) GetCreateAt() string {
	if m != nil {
		return m.CreateAt
	}
	return ""
}

func (m *NovelData) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

type NovelListReq struct {
	CateId               int32    `protobuf:"varint,1,opt,name=cate_id,json=cateId,proto3" json:"cate_id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Author               string   `protobuf:"bytes,3,opt,name=author,proto3" json:"author,omitempty"`
	Page                 int32    `protobuf:"varint,6,opt,name=page,proto3" json:"page,omitempty"`
	PageSize             int32    `protobuf:"varint,7,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NovelListReq) Reset()         { *m = NovelListReq{} }
func (m *NovelListReq) String() string { return proto.CompactTextString(m) }
func (*NovelListReq) ProtoMessage()    {}
func (*NovelListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{4}
}
func (m *NovelListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NovelListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NovelListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NovelListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NovelListReq.Merge(m, src)
}
func (m *NovelListReq) XXX_Size() int {
	return m.Size()
}
func (m *NovelListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NovelListReq.DiscardUnknown(m)
}

var xxx_messageInfo_NovelListReq proto.InternalMessageInfo

func (m *NovelListReq) GetCateId() int32 {
	if m != nil {
		return m.CateId
	}
	return 0
}

func (m *NovelListReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NovelListReq) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *NovelListReq) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *NovelListReq) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type DelCategoryReq struct {
	CategoryId           int32    `protobuf:"varint,1,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DelCategoryReq) Reset()         { *m = DelCategoryReq{} }
func (m *DelCategoryReq) String() string { return proto.CompactTextString(m) }
func (*DelCategoryReq) ProtoMessage()    {}
func (*DelCategoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{5}
}
func (m *DelCategoryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelCategoryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelCategoryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelCategoryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelCategoryReq.Merge(m, src)
}
func (m *DelCategoryReq) XXX_Size() int {
	return m.Size()
}
func (m *DelCategoryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DelCategoryReq.DiscardUnknown(m)
}

var xxx_messageInfo_DelCategoryReq proto.InternalMessageInfo

func (m *DelCategoryReq) GetCategoryId() int32 {
	if m != nil {
		return m.CategoryId
	}
	return 0
}

type CommonResponse struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Code                 int32    `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonResponse) Reset()         { *m = CommonResponse{} }
func (m *CommonResponse) String() string { return proto.CompactTextString(m) }
func (*CommonResponse) ProtoMessage()    {}
func (*CommonResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{6}
}
func (m *CommonResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonResponse.Merge(m, src)
}
func (m *CommonResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommonResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommonResponse proto.InternalMessageInfo

func (m *CommonResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *CommonResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type AddCateRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sort                 int32    `protobuf:"varint,2,opt,name=sort,proto3" json:"sort,omitempty"`
	IsShow               int32    `protobuf:"varint,3,opt,name=is_show,json=isShow,proto3" json:"is_show,omitempty"`
	Channel              int32    `protobuf:"varint,4,opt,name=channel,proto3" json:"channel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddCateRequest) Reset()         { *m = AddCateRequest{} }
func (m *AddCateRequest) String() string { return proto.CompactTextString(m) }
func (*AddCateRequest) ProtoMessage()    {}
func (*AddCateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{7}
}
func (m *AddCateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddCateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddCateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddCateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCateRequest.Merge(m, src)
}
func (m *AddCateRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddCateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddCateRequest proto.InternalMessageInfo

func (m *AddCateRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AddCateRequest) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *AddCateRequest) GetIsShow() int32 {
	if m != nil {
		return m.IsShow
	}
	return 0
}

func (m *AddCateRequest) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

type NoteRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	UserId               int32    `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	IsEnd                int32    `protobuf:"varint,3,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	Page                 int32    `protobuf:"varint,4,opt,name=page,proto3" json:"page,omitempty"`
	Size_                int32    `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteRequest) Reset()         { *m = NoteRequest{} }
func (m *NoteRequest) String() string { return proto.CompactTextString(m) }
func (*NoteRequest) ProtoMessage()    {}
func (*NoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{8}
}
func (m *NoteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteRequest.Merge(m, src)
}
func (m *NoteRequest) XXX_Size() int {
	return m.Size()
}
func (m *NoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NoteRequest proto.InternalMessageInfo

func (m *NoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NoteRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *NoteRequest) GetIsEnd() int32 {
	if m != nil {
		return m.IsEnd
	}
	return 0
}

func (m *NoteRequest) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *NoteRequest) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type ReadRequest struct {
	UserId               int32    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	NovelId              int32    `protobuf:"varint,2,opt,name=novel_id,json=novelId,proto3" json:"novel_id,omitempty"`
	ChapterNum           int32    `protobuf:"varint,3,opt,name=chapter_num,json=chapterNum,proto3" json:"chapter_num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{9}
}
func (m *ReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRequest.Merge(m, src)
}
func (m *ReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRequest proto.InternalMessageInfo

func (m *ReadRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReadRequest) GetNovelId() int32 {
	if m != nil {
		return m.NovelId
	}
	return 0
}

func (m *ReadRequest) GetChapterNum() int32 {
	if m != nil {
		return m.ChapterNum
	}
	return 0
}

type NoteResponse struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Notes                []*Note  `protobuf:"bytes,3,rep,name=notes,proto3" json:"notes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoteResponse) Reset()         { *m = NoteResponse{} }
func (m *NoteResponse) String() string { return proto.CompactTextString(m) }
func (*NoteResponse) ProtoMessage()    {}
func (*NoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{10}
}
func (m *NoteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NoteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoteResponse.Merge(m, src)
}
func (m *NoteResponse) XXX_Size() int {
	return m.Size()
}
func (m *NoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NoteResponse proto.InternalMessageInfo

func (m *NoteResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *NoteResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *NoteResponse) GetNotes() []*Note {
	if m != nil {
		return m.Notes
	}
	return nil
}

type Note struct {
	NovelName            string   `protobuf:"bytes,1,opt,name=novel_name,json=novelName,proto3" json:"novel_name,omitempty"`
	PrevChapter          string   `protobuf:"bytes,2,opt,name=prev_chapter,json=prevChapter,proto3" json:"prev_chapter,omitempty"`
	NewChapter           string   `protobuf:"bytes,3,opt,name=new_chapter,json=newChapter,proto3" json:"new_chapter,omitempty"`
	NovelId              int32    `protobuf:"varint,4,opt,name=novel_id,json=novelId,proto3" json:"novel_id,omitempty"`
	PrevNum              int32    `protobuf:"varint,5,opt,name=prev_num,json=prevNum,proto3" json:"prev_num,omitempty"`
	NewNum               int32    `protobuf:"varint,6,opt,name=new_num,json=newNum,proto3" json:"new_num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Note) Reset()         { *m = Note{} }
func (m *Note) String() string { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()    {}
func (*Note) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{11}
}
func (m *Note) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Note) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Note.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Note) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Note.Merge(m, src)
}
func (m *Note) XXX_Size() int {
	return m.Size()
}
func (m *Note) XXX_DiscardUnknown() {
	xxx_messageInfo_Note.DiscardUnknown(m)
}

var xxx_messageInfo_Note proto.InternalMessageInfo

func (m *Note) GetNovelName() string {
	if m != nil {
		return m.NovelName
	}
	return ""
}

func (m *Note) GetPrevChapter() string {
	if m != nil {
		return m.PrevChapter
	}
	return ""
}

func (m *Note) GetNewChapter() string {
	if m != nil {
		return m.NewChapter
	}
	return ""
}

func (m *Note) GetNovelId() int32 {
	if m != nil {
		return m.NovelId
	}
	return 0
}

func (m *Note) GetPrevNum() int32 {
	if m != nil {
		return m.PrevNum
	}
	return 0
}

func (m *Note) GetNewNum() int32 {
	if m != nil {
		return m.NewNum
	}
	return 0
}

type Request struct {
	CateId               int32    `protobuf:"varint,1,opt,name=cate_id,json=cateId,proto3" json:"cate_id,omitempty"`
	NovelId              int32    `protobuf:"varint,2,opt,name=novel_id,json=novelId,proto3" json:"novel_id,omitempty"`
	ChapterId            int32    `protobuf:"varint,3,opt,name=chapter_id,json=chapterId,proto3" json:"chapter_id,omitempty"`
	Page                 int32    `protobuf:"varint,4,opt,name=page,proto3" json:"page,omitempty"`
	Size_                int32    `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	Type                 string   `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Num                  int32    `protobuf:"varint,7,opt,name=num,proto3" json:"num,omitempty"`
	Name                 string   `protobuf:"bytes,8,opt,name=name,proto3" json:"name,omitempty"`
	Words                int32    `protobuf:"varint,9,opt,name=words,proto3" json:"words,omitempty"`
	UserId               int32    `protobuf:"varint,10,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	IsShow               int32    `protobuf:"varint,11,opt,name=is_show,json=isShow,proto3" json:"is_show,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{12}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetCateId() int32 {
	if m != nil {
		return m.CateId
	}
	return 0
}

func (m *Request) GetNovelId() int32 {
	if m != nil {
		return m.NovelId
	}
	return 0
}

func (m *Request) GetChapterId() int32 {
	if m != nil {
		return m.ChapterId
	}
	return 0
}

func (m *Request) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *Request) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Request) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Request) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *Request) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Request) GetWords() int32 {
	if m != nil {
		return m.Words
	}
	return 0
}

func (m *Request) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Request) GetIsShow() int32 {
	if m != nil {
		return m.IsShow
	}
	return 0
}

type Category struct {
	CateId               int32    `protobuf:"varint,1,opt,name=cate_id,json=cateId,proto3" json:"cate_id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Sort                 int32    `protobuf:"varint,3,opt,name=sort,proto3" json:"sort,omitempty"`
	Channel              int32    `protobuf:"varint,4,opt,name=channel,proto3" json:"channel,omitempty"`
	IsShow               int32    `protobuf:"varint,5,opt,name=is_show,json=isShow,proto3" json:"is_show,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Category) Reset()         { *m = Category{} }
func (m *Category) String() string { return proto.CompactTextString(m) }
func (*Category) ProtoMessage()    {}
func (*Category) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{13}
}
func (m *Category) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Category) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Category.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Category) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Category.Merge(m, src)
}
func (m *Category) XXX_Size() int {
	return m.Size()
}
func (m *Category) XXX_DiscardUnknown() {
	xxx_messageInfo_Category.DiscardUnknown(m)
}

var xxx_messageInfo_Category proto.InternalMessageInfo

func (m *Category) GetCateId() int32 {
	if m != nil {
		return m.CateId
	}
	return 0
}

func (m *Category) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Category) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *Category) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *Category) GetIsShow() int32 {
	if m != nil {
		return m.IsShow
	}
	return 0
}

type Novel struct {
	NovelId              int32    `protobuf:"varint,1,opt,name=novel_id,json=novelId,proto3" json:"novel_id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Author               string   `protobuf:"bytes,3,opt,name=author,proto3" json:"author,omitempty"`
	ChapterTotal         int32    `protobuf:"varint,4,opt,name=chapter_total,json=chapterTotal,proto3" json:"chapter_total,omitempty"`
	ChapterCurrent       int32    `protobuf:"varint,5,opt,name=chapter_current,json=chapterCurrent,proto3" json:"chapter_current,omitempty"`
	Img                  string   `protobuf:"bytes,6,opt,name=img,proto3" json:"img,omitempty"`
	Intro                string   `protobuf:"bytes,7,opt,name=intro,proto3" json:"intro,omitempty"`
	CateId               int32    `protobuf:"varint,8,opt,name=cate_id,json=cateId,proto3" json:"cate_id,omitempty"`
	Words                int32    `protobuf:"varint,9,opt,name=words,proto3" json:"words,omitempty"`
	Likes                int32    `protobuf:"varint,10,opt,name=likes,proto3" json:"likes,omitempty"`
	UnLikes              int32    `protobuf:"varint,11,opt,name=un_likes,json=unLikes,proto3" json:"un_likes,omitempty"`
	UpdatedAt            string   `protobuf:"bytes,12,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	NewChapter           string   `protobuf:"bytes,13,opt,name=new_chapter,json=newChapter,proto3" json:"new_chapter,omitempty"`
	CategoryName         string   `protobuf:"bytes,14,opt,name=category_name,json=categoryName,proto3" json:"category_name,omitempty"`
	CategoryId           int32    `protobuf:"varint,15,opt,name=category_id,json=categoryId,proto3" json:"category_id,omitempty"`
	Sort                 int32    `protobuf:"varint,16,opt,name=sort,proto3" json:"sort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Novel) Reset()         { *m = Novel{} }
func (m *Novel) String() string { return proto.CompactTextString(m) }
func (*Novel) ProtoMessage()    {}
func (*Novel) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{14}
}
func (m *Novel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Novel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Novel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Novel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Novel.Merge(m, src)
}
func (m *Novel) XXX_Size() int {
	return m.Size()
}
func (m *Novel) XXX_DiscardUnknown() {
	xxx_messageInfo_Novel.DiscardUnknown(m)
}

var xxx_messageInfo_Novel proto.InternalMessageInfo

func (m *Novel) GetNovelId() int32 {
	if m != nil {
		return m.NovelId
	}
	return 0
}

func (m *Novel) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Novel) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Novel) GetChapterTotal() int32 {
	if m != nil {
		return m.ChapterTotal
	}
	return 0
}

func (m *Novel) GetChapterCurrent() int32 {
	if m != nil {
		return m.ChapterCurrent
	}
	return 0
}

func (m *Novel) GetImg() string {
	if m != nil {
		return m.Img
	}
	return ""
}

func (m *Novel) GetIntro() string {
	if m != nil {
		return m.Intro
	}
	return ""
}

func (m *Novel) GetCateId() int32 {
	if m != nil {
		return m.CateId
	}
	return 0
}

func (m *Novel) GetWords() int32 {
	if m != nil {
		return m.Words
	}
	return 0
}

func (m *Novel) GetLikes() int32 {
	if m != nil {
		return m.Likes
	}
	return 0
}

func (m *Novel) GetUnLikes() int32 {
	if m != nil {
		return m.UnLikes
	}
	return 0
}

func (m *Novel) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

func (m *Novel) GetNewChapter() string {
	if m != nil {
		return m.NewChapter
	}
	return ""
}

func (m *Novel) GetCategoryName() string {
	if m != nil {
		return m.CategoryName
	}
	return ""
}

func (m *Novel) GetCategoryId() int32 {
	if m != nil {
		return m.CategoryId
	}
	return 0
}

func (m *Novel) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

type NovelResponse struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Novel                *Novel   `protobuf:"bytes,3,opt,name=novel,proto3" json:"novel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NovelResponse) Reset()         { *m = NovelResponse{} }
func (m *NovelResponse) String() string { return proto.CompactTextString(m) }
func (*NovelResponse) ProtoMessage()    {}
func (*NovelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{15}
}
func (m *NovelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NovelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NovelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NovelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NovelResponse.Merge(m, src)
}
func (m *NovelResponse) XXX_Size() int {
	return m.Size()
}
func (m *NovelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NovelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NovelResponse proto.InternalMessageInfo

func (m *NovelResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *NovelResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *NovelResponse) GetNovel() *Novel {
	if m != nil {
		return m.Novel
	}
	return nil
}

type Chapter struct {
	ChapterId            int32    `protobuf:"varint,1,opt,name=chapter_id,json=chapterId,proto3" json:"chapter_id,omitempty"`
	Title                string   `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Content              string   `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Words                int32    `protobuf:"varint,4,opt,name=words,proto3" json:"words,omitempty"`
	NovelId              int32    `protobuf:"varint,5,opt,name=novel_id,json=novelId,proto3" json:"novel_id,omitempty"`
	IsVip                VipType  `protobuf:"varint,6,opt,name=is_vip,json=isVip,proto3,enum=go.micro.service.novel.VipType" json:"is_vip,omitempty"`
	Num                  int32    `protobuf:"varint,7,opt,name=num,proto3" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Chapter) Reset()         { *m = Chapter{} }
func (m *Chapter) String() string { return proto.CompactTextString(m) }
func (*Chapter) ProtoMessage()    {}
func (*Chapter) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{16}
}
func (m *Chapter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chapter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chapter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chapter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chapter.Merge(m, src)
}
func (m *Chapter) XXX_Size() int {
	return m.Size()
}
func (m *Chapter) XXX_DiscardUnknown() {
	xxx_messageInfo_Chapter.DiscardUnknown(m)
}

var xxx_messageInfo_Chapter proto.InternalMessageInfo

func (m *Chapter) GetChapterId() int32 {
	if m != nil {
		return m.ChapterId
	}
	return 0
}

func (m *Chapter) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Chapter) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Chapter) GetWords() int32 {
	if m != nil {
		return m.Words
	}
	return 0
}

func (m *Chapter) GetNovelId() int32 {
	if m != nil {
		return m.NovelId
	}
	return 0
}

func (m *Chapter) GetIsVip() VipType {
	if m != nil {
		return m.IsVip
	}
	return VipType_NO_VIP
}

func (m *Chapter) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type ChapterResponse struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Chapter              *Chapter `protobuf:"bytes,3,opt,name=chapter,proto3" json:"chapter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChapterResponse) Reset()         { *m = ChapterResponse{} }
func (m *ChapterResponse) String() string { return proto.CompactTextString(m) }
func (*ChapterResponse) ProtoMessage()    {}
func (*ChapterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{17}
}
func (m *ChapterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChapterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChapterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChapterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChapterResponse.Merge(m, src)
}
func (m *ChapterResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChapterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChapterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChapterResponse proto.InternalMessageInfo

func (m *ChapterResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ChapterResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ChapterResponse) GetChapter() *Chapter {
	if m != nil {
		return m.Chapter
	}
	return nil
}

type ChaptersResponse struct {
	Code                 int32      `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Chapters             []*Chapter `protobuf:"bytes,3,rep,name=chapters,proto3" json:"chapters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ChaptersResponse) Reset()         { *m = ChaptersResponse{} }
func (m *ChaptersResponse) String() string { return proto.CompactTextString(m) }
func (*ChaptersResponse) ProtoMessage()    {}
func (*ChaptersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{18}
}
func (m *ChaptersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChaptersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChaptersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChaptersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChaptersResponse.Merge(m, src)
}
func (m *ChaptersResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChaptersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChaptersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChaptersResponse proto.InternalMessageInfo

func (m *ChaptersResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ChaptersResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ChaptersResponse) GetChapters() []*Chapter {
	if m != nil {
		return m.Chapters
	}
	return nil
}

type NovelsResponse struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Novels               []*Novel `protobuf:"bytes,3,rep,name=novels,proto3" json:"novels,omitempty"`
	Total                int32    `protobuf:"varint,4,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NovelsResponse) Reset()         { *m = NovelsResponse{} }
func (m *NovelsResponse) String() string { return proto.CompactTextString(m) }
func (*NovelsResponse) ProtoMessage()    {}
func (*NovelsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{19}
}
func (m *NovelsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NovelsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NovelsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NovelsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NovelsResponse.Merge(m, src)
}
func (m *NovelsResponse) XXX_Size() int {
	return m.Size()
}
func (m *NovelsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NovelsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NovelsResponse proto.InternalMessageInfo

func (m *NovelsResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *NovelsResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *NovelsResponse) GetNovels() []*Novel {
	if m != nil {
		return m.Novels
	}
	return nil
}

func (m *NovelsResponse) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type CateResponse struct {
	Code                 int32       `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string      `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Categories           []*Category `protobuf:"bytes,3,rep,name=categories,proto3" json:"categories,omitempty"`
	Pagnation            *Pagnation  `protobuf:"bytes,4,opt,name=pagnation,proto3" json:"pagnation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CateResponse) Reset()         { *m = CateResponse{} }
func (m *CateResponse) String() string { return proto.CompactTextString(m) }
func (*CateResponse) ProtoMessage()    {}
func (*CateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{20}
}
func (m *CateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CateResponse.Merge(m, src)
}
func (m *CateResponse) XXX_Size() int {
	return m.Size()
}
func (m *CateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CateResponse proto.InternalMessageInfo

func (m *CateResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CateResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *CateResponse) GetCategories() []*Category {
	if m != nil {
		return m.Categories
	}
	return nil
}

func (m *CateResponse) GetPagnation() *Pagnation {
	if m != nil {
		return m.Pagnation
	}
	return nil
}

type Pagnation struct {
	Page                 int64    `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
	PageSize             int64    `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Total                int64    `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pagnation) Reset()         { *m = Pagnation{} }
func (m *Pagnation) String() string { return proto.CompactTextString(m) }
func (*Pagnation) ProtoMessage()    {}
func (*Pagnation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{21}
}
func (m *Pagnation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pagnation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pagnation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pagnation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pagnation.Merge(m, src)
}
func (m *Pagnation) XXX_Size() int {
	return m.Size()
}
func (m *Pagnation) XXX_DiscardUnknown() {
	xxx_messageInfo_Pagnation.DiscardUnknown(m)
}

var xxx_messageInfo_Pagnation proto.InternalMessageInfo

func (m *Pagnation) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *Pagnation) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *Pagnation) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type ChapterDetail struct {
	Title                string   `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Content              string   `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChapterDetail) Reset()         { *m = ChapterDetail{} }
func (m *ChapterDetail) String() string { return proto.CompactTextString(m) }
func (*ChapterDetail) ProtoMessage()    {}
func (*ChapterDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{22}
}
func (m *ChapterDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChapterDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChapterDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChapterDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChapterDetail.Merge(m, src)
}
func (m *ChapterDetail) XXX_Size() int {
	return m.Size()
}
func (m *ChapterDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ChapterDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ChapterDetail proto.InternalMessageInfo

func (m *ChapterDetail) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ChapterDetail) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type Response struct {
	Code                 int32          `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string         `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Data                 *ChapterDetail `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{23}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Response) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Response) GetData() *ChapterDetail {
	if m != nil {
		return m.Data
	}
	return nil
}

type Message struct {
	Flag                 bool     `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2b5a8a103684deb, []int{24}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetFlag() bool {
	if m != nil {
		return m.Flag
	}
	return false
}

func init() {
	proto.RegisterEnum("go.micro.service.novel.VipType", VipType_name, VipType_value)
	proto.RegisterType((*DelNoteReq)(nil), "go.micro.service.novel.DelNoteReq")
	proto.RegisterType((*SetVipChapterReq)(nil), "go.micro.service.novel.SetVipChapterReq")
	proto.RegisterType((*NovelListResp)(nil), "go.micro.service.novel.NovelListResp")
	proto.RegisterType((*NovelData)(nil), "go.micro.service.novel.NovelData")
	proto.RegisterType((*NovelListReq)(nil), "go.micro.service.novel.NovelListReq")
	proto.RegisterType((*DelCategoryReq)(nil), "go.micro.service.novel.DelCategoryReq")
	proto.RegisterType((*CommonResponse)(nil), "go.micro.service.novel.CommonResponse")
	proto.RegisterType((*AddCateRequest)(nil), "go.micro.service.novel.AddCateRequest")
	proto.RegisterType((*NoteRequest)(nil), "go.micro.service.novel.NoteRequest")
	proto.RegisterType((*ReadRequest)(nil), "go.micro.service.novel.ReadRequest")
	proto.RegisterType((*NoteResponse)(nil), "go.micro.service.novel.NoteResponse")
	proto.RegisterType((*Note)(nil), "go.micro.service.novel.Note")
	proto.RegisterType((*Request)(nil), "go.micro.service.novel.Request")
	proto.RegisterType((*Category)(nil), "go.micro.service.novel.Category")
	proto.RegisterType((*Novel)(nil), "go.micro.service.novel.Novel")
	proto.RegisterType((*NovelResponse)(nil), "go.micro.service.novel.NovelResponse")
	proto.RegisterType((*Chapter)(nil), "go.micro.service.novel.Chapter")
	proto.RegisterType((*ChapterResponse)(nil), "go.micro.service.novel.ChapterResponse")
	proto.RegisterType((*ChaptersResponse)(nil), "go.micro.service.novel.ChaptersResponse")
	proto.RegisterType((*NovelsResponse)(nil), "go.micro.service.novel.NovelsResponse")
	proto.RegisterType((*CateResponse)(nil), "go.micro.service.novel.CateResponse")
	proto.RegisterType((*Pagnation)(nil), "go.micro.service.novel.Pagnation")
	proto.RegisterType((*ChapterDetail)(nil), "go.micro.service.novel.ChapterDetail")
	proto.RegisterType((*Response)(nil), "go.micro.service.novel.Response")
	proto.RegisterType((*Message)(nil), "go.micro.service.novel.Message")
}

func init() { proto.RegisterFile("proto/novel/novel.proto", fileDescriptor_f2b5a8a103684deb) }

var fileDescriptor_f2b5a8a103684deb = []byte{
	// 1516 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcf, 0x72, 0x1b, 0x45,
	0x13, 0xf7, 0x4a, 0x5a, 0x69, 0xd5, 0xb2, 0x65, 0x7d, 0x53, 0xfe, 0x12, 0x25, 0x60, 0x3b, 0xd9,
	0xfc, 0x73, 0x71, 0x30, 0x85, 0x53, 0xa4, 0x2a, 0xc5, 0x21, 0xc4, 0x36, 0x95, 0x12, 0x15, 0x44,
	0x58, 0x07, 0xc3, 0x81, 0xa0, 0xda, 0x68, 0x07, 0x7b, 0x88, 0xb4, 0xbb, 0xd9, 0x1d, 0xd9, 0x71,
	0x0e, 0x5c, 0xa0, 0x72, 0xe4, 0xcc, 0x8d, 0xc7, 0x80, 0x13, 0x67, 0x8e, 0x54, 0xf1, 0x02, 0x54,
	0x78, 0x01, 0x1e, 0x81, 0x9a, 0x9e, 0x99, 0xd5, 0xac, 0xec, 0x95, 0xac, 0x14, 0x17, 0x7b, 0xa6,
	0xb7, 0xa7, 0x7b, 0xe6, 0xd7, 0xfd, 0xeb, 0xe9, 0x11, 0x5c, 0x8c, 0x93, 0x88, 0x47, 0xef, 0x86,
	0xd1, 0x11, 0x1d, 0xc8, 0xbf, 0x9b, 0x28, 0x21, 0x17, 0x0e, 0xa2, 0xcd, 0x21, 0xeb, 0x27, 0xd1,
	0x66, 0x4a, 0x93, 0x23, 0xd6, 0xa7, 0x9b, 0xf8, 0xd5, 0xbd, 0x0b, 0xb0, 0x4b, 0x07, 0xdd, 0x88,
	0x53, 0x8f, 0x3e, 0x27, 0x2d, 0x28, 0x8f, 0x58, 0xd0, 0xb6, 0xae, 0x58, 0x1b, 0xb6, 0x27, 0x86,
	0xe4, 0x12, 0x38, 0xa8, 0xd8, 0x63, 0x41, 0xbb, 0x84, 0xe2, 0x1a, 0xce, 0x3b, 0x81, 0xfb, 0xca,
	0x82, 0xd6, 0x1e, 0xe5, 0xfb, 0x2c, 0xde, 0x39, 0xf4, 0x63, 0x4e, 0x13, 0x61, 0xc1, 0xd4, 0xb7,
	0x72, 0xfa, 0x64, 0x1d, 0x1a, 0x43, 0x16, 0xf6, 0xfa, 0x52, 0x59, 0x59, 0x83, 0x21, 0x0b, 0xd5,
	0x72, 0x54, 0xf0, 0x5f, 0x64, 0x0a, 0x65, 0xa5, 0xe0, 0xbf, 0xd0, 0x0a, 0xff, 0x87, 0x2a, 0x4b,
	0x7b, 0x47, 0x2c, 0x6e, 0x57, 0xf0, 0x9b, 0xcd, 0xd2, 0x7d, 0x16, 0xbb, 0x3f, 0x5b, 0xb0, 0xd4,
	0x15, 0x4e, 0x1e, 0xb2, 0x94, 0x7b, 0x34, 0x8d, 0xc9, 0x5d, 0xa8, 0xa2, 0xd7, 0xb4, 0x6d, 0x5d,
	0x29, 0x6f, 0x34, 0xb6, 0xae, 0x6e, 0x9e, 0x7d, 0xfc, 0x4d, 0x5c, 0xb6, 0xeb, 0x73, 0xdf, 0x53,
	0x0b, 0x08, 0x81, 0x4a, 0x3f, 0x0a, 0xa8, 0xda, 0x1e, 0x8e, 0xc9, 0x3d, 0xa8, 0xc7, 0xfe, 0x41,
	0xe8, 0x73, 0x16, 0x85, 0xb8, 0xad, 0x29, 0x16, 0x1f, 0x69, 0x45, 0x6f, 0xbc, 0xc6, 0xfd, 0xb1,
	0x04, 0xf5, 0xcc, 0x15, 0x69, 0x42, 0x49, 0xa1, 0x53, 0xf6, 0x4a, 0x2c, 0x10, 0x2e, 0x43, 0x7f,
	0x28, 0x5d, 0xd6, 0x3d, 0x1c, 0x93, 0x0b, 0x50, 0xf5, 0x47, 0xfc, 0x30, 0x92, 0x30, 0xd4, 0x3d,
	0x35, 0x23, 0x17, 0xa1, 0xd6, 0xf7, 0x39, 0x15, 0xf0, 0x56, 0xd0, 0x40, 0x55, 0x4c, 0x3b, 0x01,
	0x79, 0x0b, 0xea, 0xf8, 0x01, 0x2d, 0xd9, 0xb8, 0xc6, 0x11, 0x82, 0xae, 0xb0, 0xd6, 0x82, 0x32,
	0x1b, 0x1e, 0xb4, 0xab, 0x28, 0x16, 0x43, 0x72, 0x0d, 0x96, 0x14, 0xce, 0x3d, 0x1e, 0x71, 0x7f,
	0xd0, 0xae, 0xa1, 0xb5, 0x45, 0x25, 0x7c, 0x2c, 0x64, 0xe4, 0x16, 0x2c, 0x6b, 0xa5, 0xfe, 0x28,
	0x49, 0x68, 0xc8, 0xdb, 0x0e, 0xaa, 0x35, 0x95, 0x78, 0x47, 0x4a, 0xd1, 0x79, 0x42, 0x85, 0x7b,
	0x9f, 0xb7, 0xeb, 0xca, 0x39, 0x0a, 0xee, 0x73, 0x71, 0xbc, 0x34, 0x4a, 0x78, 0x1b, 0x24, 0xa2,
	0x62, 0xec, 0xfe, 0x60, 0xc1, 0xa2, 0x11, 0xb2, 0xe7, 0xe6, 0xb9, 0x64, 0xda, 0xe8, 0x73, 0xcd,
	0x03, 0x0e, 0x81, 0x4a, 0xec, 0x1f, 0x50, 0x3c, 0xa7, 0xed, 0xe1, 0x58, 0x6c, 0x4d, 0xfc, 0xef,
	0xa5, 0xec, 0x25, 0xc5, 0x43, 0xda, 0x9e, 0x23, 0x04, 0x7b, 0xec, 0x25, 0x75, 0xdf, 0x83, 0xe6,
	0x2e, 0x1d, 0xec, 0xf8, 0x9c, 0x1e, 0x44, 0xc9, 0x89, 0xd8, 0xc7, 0x3a, 0x34, 0xfa, 0x6a, 0x3a,
	0xde, 0x0b, 0x68, 0x51, 0x27, 0x70, 0xef, 0x40, 0x73, 0x27, 0x1a, 0x0e, 0xa3, 0x50, 0x24, 0x5a,
	0x14, 0xa6, 0x08, 0xee, 0x30, 0x3d, 0x40, 0xd5, 0xba, 0x27, 0x86, 0x67, 0xe5, 0x90, 0xfb, 0x0c,
	0x9a, 0xf7, 0x83, 0x40, 0xb8, 0xf2, 0xe8, 0xf3, 0x11, 0x4d, 0x79, 0x76, 0x32, 0xcb, 0x38, 0x99,
	0xc6, 0xaa, 0x34, 0xc6, 0x4a, 0x40, 0xc3, 0xd2, 0x5e, 0x7a, 0x18, 0x1d, 0x2b, 0x4a, 0x54, 0x59,
	0xba, 0x77, 0x18, 0x1d, 0x93, 0x36, 0xd4, 0xfa, 0x87, 0x7e, 0x18, 0xd2, 0x81, 0xe2, 0x83, 0x9e,
	0xba, 0x27, 0xd0, 0x50, 0x94, 0x2e, 0xf4, 0x74, 0x11, 0x6a, 0xa3, 0x94, 0x26, 0x63, 0x5e, 0x57,
	0xc5, 0xb4, 0x13, 0x28, 0x92, 0xd1, 0x30, 0x50, 0xde, 0x6c, 0x96, 0x7e, 0x14, 0x06, 0x19, 0xb6,
	0x15, 0x03, 0x5b, 0xb1, 0x5b, 0x01, 0xab, 0xad, 0x76, 0x2b, 0x20, 0x7d, 0x0a, 0x0d, 0x8f, 0xfa,
	0x81, 0x76, 0x6d, 0xb8, 0xb1, 0x72, 0x6e, 0x8a, 0x0b, 0x0b, 0xc6, 0x40, 0xa5, 0x5d, 0x38, 0x1a,
	0xea, 0x3a, 0xa0, 0x44, 0xdd, 0xd1, 0xd0, 0x3d, 0x14, 0xc9, 0x23, 0x8e, 0xa7, 0x22, 0xa0, 0xf1,
	0xb6, 0x0c, 0xce, 0xaa, 0xa8, 0x94, 0xc6, 0x51, 0xd9, 0x02, 0x3b, 0x8c, 0x38, 0x4d, 0xdb, 0x65,
	0xac, 0x09, 0x6f, 0x17, 0xd7, 0x04, 0x4e, 0x3d, 0xa9, 0xea, 0xfe, 0x6a, 0x41, 0x45, 0xcc, 0xc9,
	0x2a, 0x80, 0xdc, 0xae, 0x01, 0x64, 0x1d, 0x25, 0x48, 0xb0, 0xab, 0xb0, 0x18, 0x27, 0xf4, 0x28,
	0x57, 0xdc, 0xea, 0x5e, 0x43, 0xc8, 0x8c, 0xea, 0x16, 0xd2, 0xe3, 0x5c, 0x75, 0xab, 0x7b, 0x10,
	0xd2, 0x63, 0xad, 0x60, 0x22, 0x52, 0xc9, 0x23, 0x72, 0x09, 0x1c, 0x34, 0x2f, 0xe0, 0x90, 0x60,
	0xd7, 0xc4, 0xbc, 0x3b, 0x1a, 0x0a, 0x80, 0x85, 0x59, 0xf1, 0x45, 0xa6, 0x7d, 0x35, 0xa4, 0xc7,
	0x02, 0xa4, 0x57, 0x25, 0xa8, 0x19, 0x51, 0x38, 0x9b, 0x5d, 0x53, 0xa2, 0xb0, 0x0a, 0x1a, 0x72,
	0xf1, 0x51, 0x06, 0xa1, 0xae, 0x24, 0x9d, 0x73, 0xe7, 0x83, 0x90, 0xf1, 0x93, 0x98, 0xaa, 0xda,
	0x83, 0x63, 0x11, 0x1b, 0xb1, 0x5f, 0xc9, 0x46, 0x31, 0xcc, 0x32, 0xd4, 0x31, 0x32, 0x74, 0x05,
	0xec, 0xe3, 0x28, 0x09, 0x52, 0x2c, 0x28, 0xb6, 0x27, 0x27, 0x66, 0x42, 0x41, 0x2e, 0xa1, 0x0c,
	0x9a, 0x34, 0x4c, 0x9a, 0xb8, 0xdf, 0x81, 0xa3, 0x19, 0x3e, 0x5f, 0x99, 0xd1, 0x64, 0x2c, 0x1b,
	0x64, 0x2c, 0xe4, 0x9c, 0xe9, 0xdf, 0xce, 0xf9, 0xff, 0xad, 0x0c, 0x36, 0xd6, 0xba, 0x69, 0x97,
	0xe3, 0x3c, 0x65, 0xee, 0x54, 0xed, 0x96, 0x3b, 0x99, 0x59, 0xbb, 0xe5, 0xb6, 0x26, 0x6b, 0xf7,
	0xe9, 0xbb, 0x61, 0x05, 0x6c, 0x16, 0xf2, 0x24, 0xc2, 0x00, 0xd5, 0x3d, 0x39, 0x31, 0xa1, 0x73,
	0x72, 0xd0, 0x9d, 0x1d, 0xa7, 0x15, 0xb0, 0x07, 0xec, 0x19, 0x4d, 0x55, 0x94, 0xe4, 0x44, 0x20,
	0x30, 0x0a, 0x7b, 0xf2, 0x83, 0x8c, 0x52, 0x6d, 0x14, 0x3e, 0xc4, 0x4f, 0xab, 0x00, 0xa3, 0x38,
	0xf0, 0x39, 0x0d, 0xc4, 0x25, 0xb2, 0x28, 0x19, 0xa6, 0x24, 0xf7, 0xf9, 0x24, 0x7d, 0x96, 0x4e,
	0xd1, 0x47, 0xa0, 0xa2, 0x2b, 0x37, 0x42, 0xd9, 0x44, 0x95, 0x45, 0x2d, 0x44, 0x9e, 0x4e, 0x94,
	0xf7, 0xe5, 0xc9, 0xf2, 0x9e, 0xc5, 0xbc, 0x65, 0x5c, 0x56, 0xdf, 0xaa, 0xf6, 0x62, 0xce, 0x7a,
	0x73, 0x5b, 0xd4, 0x9b, 0x23, 0x3a, 0x50, 0x1d, 0xc3, 0xea, 0xd4, 0x1e, 0xc4, 0x93, 0xba, 0xee,
	0x9f, 0x16, 0xd4, 0xf4, 0x89, 0xf2, 0x0c, 0xb4, 0x26, 0x19, 0xb8, 0x02, 0x36, 0x67, 0x7c, 0xa0,
	0x73, 0x46, 0x4e, 0x30, 0x41, 0xa3, 0x90, 0x8b, 0x78, 0xcb, 0xac, 0xd1, 0xd3, 0x71, 0x9c, 0x2a,
	0x66, 0x9c, 0xcc, 0x9c, 0xb4, 0xf3, 0x39, 0x79, 0x27, 0x6b, 0xb7, 0x44, 0x72, 0x34, 0xb7, 0xd6,
	0x8b, 0x4e, 0xb0, 0xcf, 0xe2, 0xc7, 0x27, 0x31, 0x55, 0xfd, 0xd8, 0x69, 0x7a, 0xbb, 0x09, 0x2c,
	0x67, 0x3d, 0xe2, 0x5c, 0x18, 0xde, 0x45, 0xba, 0x65, 0x05, 0xb3, 0x51, 0xbc, 0x07, 0x6d, 0x5f,
	0xeb, 0xbb, 0x23, 0x68, 0x29, 0x59, 0x3a, 0xa7, 0xd3, 0x0f, 0xc0, 0x51, 0x46, 0xf4, 0x5d, 0x31,
	0xd3, 0x6b, 0xb6, 0xc0, 0xfd, 0xde, 0x82, 0x26, 0x46, 0x74, 0x5e, 0xaf, 0xef, 0x67, 0x3d, 0xab,
	0xf4, 0x39, 0x23, 0x5f, 0x74, 0xbf, 0x2a, 0xb2, 0xc0, 0x28, 0x02, 0x72, 0xe2, 0xfe, 0x62, 0xc1,
	0xa2, 0xec, 0x35, 0xe6, 0xda, 0xc3, 0x87, 0xa0, 0xb9, 0xc0, 0xb2, 0x7b, 0xf2, 0x4a, 0xe1, 0xd9,
	0x75, 0xdb, 0x64, 0xac, 0xc9, 0xb7, 0xca, 0x95, 0x37, 0x68, 0x95, 0x3d, 0xa8, 0x67, 0xf2, 0xec,
	0x92, 0x91, 0xbd, 0xf2, 0x19, 0x0d, 0x5d, 0x09, 0x3f, 0x64, 0x0d, 0xdd, 0x18, 0x8d, 0x32, 0x7e,
	0x50, 0x68, 0xdc, 0x83, 0x25, 0x15, 0xa8, 0x5d, 0xca, 0x7d, 0x36, 0x18, 0x53, 0xc7, 0x2a, 0xa0,
	0x4e, 0x29, 0x47, 0x1d, 0xf7, 0x19, 0x38, 0x73, 0x27, 0x6e, 0x25, 0xf0, 0xb9, 0xaf, 0xb2, 0xf6,
	0xc6, 0x8c, 0xfc, 0x91, 0xdb, 0xf2, 0x70, 0x89, 0xbb, 0x0a, 0xb5, 0x4f, 0x68, 0x9a, 0xaa, 0x0b,
	0xf5, 0x9b, 0x81, 0x2f, 0x7b, 0x4b, 0xc7, 0xc3, 0xf1, 0x3b, 0x57, 0xa1, 0xa6, 0xf8, 0x46, 0x00,
	0xaa, 0xdd, 0x4f, 0x7b, 0xfb, 0x9d, 0x47, 0xad, 0x05, 0x31, 0xee, 0xec, 0xe1, 0xd8, 0xda, 0xfa,
	0x07, 0xc0, 0xc1, 0x2c, 0xd9, 0x4b, 0x8e, 0xc8, 0x13, 0x58, 0xca, 0xbd, 0xd2, 0xc8, 0x46, 0xd1,
	0x66, 0x26, 0x1f, 0x73, 0x97, 0x0b, 0x43, 0xaf, 0xc1, 0x70, 0x17, 0xc8, 0x23, 0x68, 0x7c, 0x8e,
	0x45, 0x5a, 0x5e, 0x71, 0xd3, 0xb3, 0xf6, 0x5c, 0x16, 0x9f, 0xc0, 0xe2, 0x03, 0xca, 0xb3, 0xd7,
	0x01, 0xb9, 0x3e, 0xd5, 0xa4, 0x7a, 0x40, 0x5c, 0xbe, 0x71, 0x0e, 0xad, 0x34, 0x76, 0x17, 0x48,
	0x0f, 0x1a, 0x46, 0xcf, 0x4f, 0x6e, 0x16, 0xad, 0xcb, 0x3f, 0x0c, 0x2e, 0x17, 0xea, 0xe5, 0x5f,
	0x03, 0xee, 0x02, 0xf9, 0x0a, 0x9a, 0x12, 0x91, 0xcc, 0xc7, 0x4c, 0x0a, 0xcd, 0x61, 0xbd, 0x07,
	0x0d, 0xf5, 0x8e, 0x78, 0x30, 0x75, 0xfb, 0xf9, 0xc7, 0xc6, 0x1c, 0x0e, 0xbe, 0x84, 0xa5, 0x07,
	0x94, 0x2b, 0x07, 0x82, 0xd2, 0xeb, 0xc5, 0x31, 0x93, 0xb6, 0xaf, 0x4f, 0x3b, 0x5e, 0xce, 0x72,
	0x16, 0xd8, 0x6d, 0x71, 0xd7, 0xce, 0x34, 0x3c, 0x3d, 0xa6, 0x86, 0xe5, 0xaf, 0xe1, 0x7f, 0xda,
	0x72, 0xba, 0x7d, 0xb2, 0x23, 0xfb, 0x92, 0x99, 0xe6, 0x6f, 0x4e, 0x35, 0x9f, 0xe6, 0x42, 0xba,
	0x6c, 0xd8, 0x97, 0x9d, 0xc4, 0x7f, 0x67, 0xbd, 0x0f, 0x2b, 0x02, 0x71, 0x75, 0x83, 0x6c, 0x9f,
	0x74, 0xf5, 0x3b, 0x68, 0x96, 0x8b, 0x8d, 0x19, 0x65, 0x25, 0x7f, 0x84, 0xe6, 0xd8, 0xc9, 0xf9,
	0xe0, 0xbf, 0x35, 0xeb, 0xd6, 0x1b, 0x5b, 0xff, 0x02, 0x1c, 0x04, 0x88, 0xd3, 0x94, 0x5c, 0x9b,
	0xfa, 0xb0, 0x9a, 0x95, 0x33, 0xe6, 0xc3, 0xce, 0x5d, 0x20, 0x7b, 0xe0, 0x7c, 0x1c, 0xb1, 0x10,
	0xdf, 0x60, 0x6f, 0x9e, 0x88, 0x13, 0x46, 0x3f, 0x83, 0x9a, 0xfa, 0xd1, 0x8b, 0xb8, 0x53, 0xe8,
	0xaf, 0xf6, 0x7b, 0x9e, 0xa2, 0xb5, 0xdd, 0xfa, 0xfd, 0xf5, 0x9a, 0xf5, 0xc7, 0xeb, 0x35, 0xeb,
	0xaf, 0xd7, 0x6b, 0xd6, 0x4f, 0x7f, 0xaf, 0x2d, 0x3c, 0xad, 0xe2, 0x0f, 0x6f, 0xb7, 0xff, 0x0d,
	0x00, 0x00, 0xff, 0xff, 0x13, 0x2c, 0x56, 0xd5, 0x93, 0x13, 0x00, 0x00,
}

func (m *DelNoteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelNoteReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelNoteReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NovelId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.NovelId))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetVipChapterReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVipChapterReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVipChapterReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsVip != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.IsVip))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxChapter != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.MaxChapter))
		i--
		dAtA[i] = 0x18
	}
	if m.MinChapter != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.MinChapter))
		i--
		dAtA[i] = 0x10
	}
	if m.NovelId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.NovelId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NovelListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NovelListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NovelListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pagnation != nil {
		{
			size, err := m.Pagnation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNovel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Novels) > 0 {
		for iNdEx := len(m.Novels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Novels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNovel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NovelData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NovelData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NovelData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sort != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x50
	}
	if len(m.CreateAt) > 0 {
		i -= len(m.CreateAt)
		copy(dAtA[i:], m.CreateAt)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.CreateAt)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ChapterCurrent != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.ChapterCurrent))
		i--
		dAtA[i] = 0x40
	}
	if m.ChapterTotal != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.ChapterTotal))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Img) > 0 {
		i -= len(m.Img)
		copy(dAtA[i:], m.Img)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Img)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CateName) > 0 {
		i -= len(m.CateName)
		copy(dAtA[i:], m.CateName)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.CateName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CateId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.CateId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NovelListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NovelListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NovelListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PageSize != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x38
	}
	if m.Page != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.CateId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.CateId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelCategoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelCategoryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelCategoryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CategoryId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.CategoryId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommonResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddCateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddCateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Channel != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x20
	}
	if m.IsShow != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.IsShow))
		i--
		dAtA[i] = 0x18
	}
	if m.Sort != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Size_ != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if m.Page != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x20
	}
	if m.IsEnd != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.IsEnd))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChapterNum != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.ChapterNum))
		i--
		dAtA[i] = 0x18
	}
	if m.NovelId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.NovelId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NoteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Notes) > 0 {
		for iNdEx := len(m.Notes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Notes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNovel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Note) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Note) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Note) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewNum != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.NewNum))
		i--
		dAtA[i] = 0x30
	}
	if m.PrevNum != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.PrevNum))
		i--
		dAtA[i] = 0x28
	}
	if m.NovelId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.NovelId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NewChapter) > 0 {
		i -= len(m.NewChapter)
		copy(dAtA[i:], m.NewChapter)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.NewChapter)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PrevChapter) > 0 {
		i -= len(m.PrevChapter)
		copy(dAtA[i:], m.PrevChapter)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.PrevChapter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NovelName) > 0 {
		i -= len(m.NovelName)
		copy(dAtA[i:], m.NovelName)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.NovelName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShow != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.IsShow))
		i--
		dAtA[i] = 0x58
	}
	if m.UserId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x50
	}
	if m.Words != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Words))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x42
	}
	if m.Num != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x32
	}
	if m.Size_ != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if m.Page != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x20
	}
	if m.ChapterId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.ChapterId))
		i--
		dAtA[i] = 0x18
	}
	if m.NovelId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.NovelId))
		i--
		dAtA[i] = 0x10
	}
	if m.CateId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.CateId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Category) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Category) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Category) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShow != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.IsShow))
		i--
		dAtA[i] = 0x28
	}
	if m.Channel != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x20
	}
	if m.Sort != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.CateId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.CateId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Novel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Novel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Novel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sort != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CategoryId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.CategoryId))
		i--
		dAtA[i] = 0x78
	}
	if len(m.CategoryName) > 0 {
		i -= len(m.CategoryName)
		copy(dAtA[i:], m.CategoryName)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.CategoryName)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.NewChapter) > 0 {
		i -= len(m.NewChapter)
		copy(dAtA[i:], m.NewChapter)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.NewChapter)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x62
	}
	if m.UnLikes != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.UnLikes))
		i--
		dAtA[i] = 0x58
	}
	if m.Likes != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Likes))
		i--
		dAtA[i] = 0x50
	}
	if m.Words != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Words))
		i--
		dAtA[i] = 0x48
	}
	if m.CateId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.CateId))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Intro) > 0 {
		i -= len(m.Intro)
		copy(dAtA[i:], m.Intro)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Intro)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Img) > 0 {
		i -= len(m.Img)
		copy(dAtA[i:], m.Img)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Img)))
		i--
		dAtA[i] = 0x32
	}
	if m.ChapterCurrent != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.ChapterCurrent))
		i--
		dAtA[i] = 0x28
	}
	if m.ChapterTotal != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.ChapterTotal))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.NovelId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.NovelId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NovelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NovelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NovelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Novel != nil {
		{
			size, err := m.Novel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNovel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Chapter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chapter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chapter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x38
	}
	if m.IsVip != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.IsVip))
		i--
		dAtA[i] = 0x30
	}
	if m.NovelId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.NovelId))
		i--
		dAtA[i] = 0x28
	}
	if m.Words != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Words))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChapterId != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.ChapterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChapterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChapterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Chapter != nil {
		{
			size, err := m.Chapter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNovel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChaptersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChaptersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChaptersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Chapters) > 0 {
		for iNdEx := len(m.Chapters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chapters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNovel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NovelsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NovelsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NovelsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Novels) > 0 {
		for iNdEx := len(m.Novels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Novels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNovel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pagnation != nil {
		{
			size, err := m.Pagnation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNovel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Categories) > 0 {
		for iNdEx := len(m.Categories) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Categories[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNovel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pagnation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pagnation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pagnation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.PageSize != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChapterDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChapterDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNovel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintNovel(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintNovel(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag {
		i--
		if m.Flag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNovel(dAtA []byte, offset int, v uint64) int {
	offset -= sovNovel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DelNoteReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovNovel(uint64(m.Uid))
	}
	if m.NovelId != 0 {
		n += 1 + sovNovel(uint64(m.NovelId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVipChapterReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NovelId != 0 {
		n += 1 + sovNovel(uint64(m.NovelId))
	}
	if m.MinChapter != 0 {
		n += 1 + sovNovel(uint64(m.MinChapter))
	}
	if m.MaxChapter != 0 {
		n += 1 + sovNovel(uint64(m.MaxChapter))
	}
	if m.IsVip != 0 {
		n += 1 + sovNovel(uint64(m.IsVip))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NovelListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Novels) > 0 {
		for _, e := range m.Novels {
			l = e.Size()
			n += 1 + l + sovNovel(uint64(l))
		}
	}
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	if m.Pagnation != nil {
		l = m.Pagnation.Size()
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NovelData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovNovel(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.CateId != 0 {
		n += 1 + sovNovel(uint64(m.CateId))
	}
	l = len(m.CateName)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.Img)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.ChapterTotal != 0 {
		n += 1 + sovNovel(uint64(m.ChapterTotal))
	}
	if m.ChapterCurrent != 0 {
		n += 1 + sovNovel(uint64(m.ChapterCurrent))
	}
	l = len(m.CreateAt)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovNovel(uint64(m.Sort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NovelListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CateId != 0 {
		n += 1 + sovNovel(uint64(m.CateId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovNovel(uint64(m.Page))
	}
	if m.PageSize != 0 {
		n += 1 + sovNovel(uint64(m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DelCategoryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CategoryId != 0 {
		n += 1 + sovNovel(uint64(m.CategoryId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddCateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovNovel(uint64(m.Sort))
	}
	if m.IsShow != 0 {
		n += 1 + sovNovel(uint64(m.IsShow))
	}
	if m.Channel != 0 {
		n += 1 + sovNovel(uint64(m.Channel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovNovel(uint64(m.UserId))
	}
	if m.IsEnd != 0 {
		n += 1 + sovNovel(uint64(m.IsEnd))
	}
	if m.Page != 0 {
		n += 1 + sovNovel(uint64(m.Page))
	}
	if m.Size_ != 0 {
		n += 1 + sovNovel(uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovNovel(uint64(m.UserId))
	}
	if m.NovelId != 0 {
		n += 1 + sovNovel(uint64(m.NovelId))
	}
	if m.ChapterNum != 0 {
		n += 1 + sovNovel(uint64(m.ChapterNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NoteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if len(m.Notes) > 0 {
		for _, e := range m.Notes {
			l = e.Size()
			n += 1 + l + sovNovel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Note) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NovelName)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.PrevChapter)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.NewChapter)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.NovelId != 0 {
		n += 1 + sovNovel(uint64(m.NovelId))
	}
	if m.PrevNum != 0 {
		n += 1 + sovNovel(uint64(m.PrevNum))
	}
	if m.NewNum != 0 {
		n += 1 + sovNovel(uint64(m.NewNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CateId != 0 {
		n += 1 + sovNovel(uint64(m.CateId))
	}
	if m.NovelId != 0 {
		n += 1 + sovNovel(uint64(m.NovelId))
	}
	if m.ChapterId != 0 {
		n += 1 + sovNovel(uint64(m.ChapterId))
	}
	if m.Page != 0 {
		n += 1 + sovNovel(uint64(m.Page))
	}
	if m.Size_ != 0 {
		n += 1 + sovNovel(uint64(m.Size_))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Num != 0 {
		n += 1 + sovNovel(uint64(m.Num))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Words != 0 {
		n += 1 + sovNovel(uint64(m.Words))
	}
	if m.UserId != 0 {
		n += 1 + sovNovel(uint64(m.UserId))
	}
	if m.IsShow != 0 {
		n += 1 + sovNovel(uint64(m.IsShow))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Category) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CateId != 0 {
		n += 1 + sovNovel(uint64(m.CateId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovNovel(uint64(m.Sort))
	}
	if m.Channel != 0 {
		n += 1 + sovNovel(uint64(m.Channel))
	}
	if m.IsShow != 0 {
		n += 1 + sovNovel(uint64(m.IsShow))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Novel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NovelId != 0 {
		n += 1 + sovNovel(uint64(m.NovelId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.ChapterTotal != 0 {
		n += 1 + sovNovel(uint64(m.ChapterTotal))
	}
	if m.ChapterCurrent != 0 {
		n += 1 + sovNovel(uint64(m.ChapterCurrent))
	}
	l = len(m.Img)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.Intro)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.CateId != 0 {
		n += 1 + sovNovel(uint64(m.CateId))
	}
	if m.Words != 0 {
		n += 1 + sovNovel(uint64(m.Words))
	}
	if m.Likes != 0 {
		n += 1 + sovNovel(uint64(m.Likes))
	}
	if m.UnLikes != 0 {
		n += 1 + sovNovel(uint64(m.UnLikes))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.NewChapter)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.CategoryName)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.CategoryId != 0 {
		n += 1 + sovNovel(uint64(m.CategoryId))
	}
	if m.Sort != 0 {
		n += 2 + sovNovel(uint64(m.Sort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NovelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Novel != nil {
		l = m.Novel.Size()
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Chapter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChapterId != 0 {
		n += 1 + sovNovel(uint64(m.ChapterId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Words != 0 {
		n += 1 + sovNovel(uint64(m.Words))
	}
	if m.NovelId != 0 {
		n += 1 + sovNovel(uint64(m.NovelId))
	}
	if m.IsVip != 0 {
		n += 1 + sovNovel(uint64(m.IsVip))
	}
	if m.Num != 0 {
		n += 1 + sovNovel(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChapterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Chapter != nil {
		l = m.Chapter.Size()
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChaptersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if len(m.Chapters) > 0 {
		for _, e := range m.Chapters {
			l = e.Size()
			n += 1 + l + sovNovel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NovelsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if len(m.Novels) > 0 {
		for _, e := range m.Novels {
			l = e.Size()
			n += 1 + l + sovNovel(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovNovel(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if len(m.Categories) > 0 {
		for _, e := range m.Categories {
			l = e.Size()
			n += 1 + l + sovNovel(uint64(l))
		}
	}
	if m.Pagnation != nil {
		l = m.Pagnation.Size()
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pagnation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovNovel(uint64(m.Page))
	}
	if m.PageSize != 0 {
		n += 1 + sovNovel(uint64(m.PageSize))
	}
	if m.Total != 0 {
		n += 1 + sovNovel(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChapterDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNovel(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovNovel(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNovel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNovel(x uint64) (n int) {
	return sovNovel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DelNoteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelNoteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelNoteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NovelId", wireType)
			}
			m.NovelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NovelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVipChapterReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVipChapterReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVipChapterReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NovelId", wireType)
			}
			m.NovelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NovelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinChapter", wireType)
			}
			m.MinChapter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinChapter |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChapter", wireType)
			}
			m.MaxChapter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxChapter |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVip", wireType)
			}
			m.IsVip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsVip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NovelListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NovelListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NovelListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Novels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Novels = append(m.Novels, &NovelData{})
			if err := m.Novels[len(m.Novels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagnation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagnation == nil {
				m.Pagnation = &Pagnation{}
			}
			if err := m.Pagnation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NovelData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NovelData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NovelData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CateId", wireType)
			}
			m.CateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CateId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Img = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterTotal", wireType)
			}
			m.ChapterTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChapterTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterCurrent", wireType)
			}
			m.ChapterCurrent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChapterCurrent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NovelListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NovelListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NovelListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CateId", wireType)
			}
			m.CateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CateId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelCategoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelCategoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelCategoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			m.CategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CategoryId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddCateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddCateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddCateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShow", wireType)
			}
			m.IsShow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsShow |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			m.IsEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsEnd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NovelId", wireType)
			}
			m.NovelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NovelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterNum", wireType)
			}
			m.ChapterNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChapterNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = append(m.Notes, &Note{})
			if err := m.Notes[len(m.Notes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Note) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Note: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Note: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NovelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NovelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevChapter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevChapter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChapter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewChapter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NovelId", wireType)
			}
			m.NovelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NovelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevNum", wireType)
			}
			m.PrevNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNum", wireType)
			}
			m.NewNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CateId", wireType)
			}
			m.CateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CateId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NovelId", wireType)
			}
			m.NovelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NovelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterId", wireType)
			}
			m.ChapterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChapterId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Words", wireType)
			}
			m.Words = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Words |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShow", wireType)
			}
			m.IsShow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsShow |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Category) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Category: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Category: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CateId", wireType)
			}
			m.CateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CateId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShow", wireType)
			}
			m.IsShow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsShow |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Novel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Novel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Novel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NovelId", wireType)
			}
			m.NovelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NovelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterTotal", wireType)
			}
			m.ChapterTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChapterTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterCurrent", wireType)
			}
			m.ChapterCurrent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChapterCurrent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Img = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intro", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intro = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CateId", wireType)
			}
			m.CateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CateId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Words", wireType)
			}
			m.Words = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Words |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Likes", wireType)
			}
			m.Likes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Likes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnLikes", wireType)
			}
			m.UnLikes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnLikes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChapter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewChapter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			m.CategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CategoryId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NovelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NovelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NovelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Novel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Novel == nil {
				m.Novel = &Novel{}
			}
			if err := m.Novel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chapter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chapter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chapter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterId", wireType)
			}
			m.ChapterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChapterId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Words", wireType)
			}
			m.Words = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Words |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NovelId", wireType)
			}
			m.NovelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NovelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVip", wireType)
			}
			m.IsVip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsVip |= VipType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chapter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chapter == nil {
				m.Chapter = &Chapter{}
			}
			if err := m.Chapter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChaptersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChaptersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChaptersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chapters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chapters = append(m.Chapters, &Chapter{})
			if err := m.Chapters[len(m.Chapters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NovelsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NovelsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NovelsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Novels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Novels = append(m.Novels, &Novel{})
			if err := m.Novels[len(m.Novels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, &Category{})
			if err := m.Categories[len(m.Categories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagnation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagnation == nil {
				m.Pagnation = &Pagnation{}
			}
			if err := m.Pagnation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pagnation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pagnation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pagnation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNovel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNovel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ChapterDetail{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNovel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNovel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNovel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNovel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNovel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNovel
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNovel
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNovel
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNovel        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNovel          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNovel = fmt.Errorf("proto: unexpected end of group")
)
